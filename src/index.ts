/**
 * Function type that generates a string from a given set of parameters and utilities.
 *
 * @template T A record type that defines the shape of the parameters.
 * @template U A record type that defines the shape of the utility functions.
 */
type Templatable<T extends { [key: string]: any }, U> = (
  params: T,
  utils: U,
) => string;

/**
 * Class that handles template files.
 *
 * @template T A record type that defines the shape of the template data.
 * @template U A record type that defines the shape of the utility functions.
 */
class TemplateFile<
  T extends { [key: string]: any },
  U extends { [key: string]: any },
> {
  /**
   * Sets the template function for this instance.
   *
   * @param templateFunc A function to be used as a template.
   * @returns The template function.
   */
  template?: Templatable<T, U>;
  testData?: T;
  utilities: U;

  constructor(input: {
    utilities: U;
    template?: Templatable<T, U>;
    testData?: T;
  }) {
    this.utilities = input.utilities;
    this.template = input.template;
    this.testData = input.testData;
  }

  /**
   * Sets the template function for this instance.
   *
   * @param templateFunc A function to be used as a template.
   * @param args - The data to be passed into the template.
   * @param utils - An object containing utility functions.
   * @returns The template function.
   */
  setTemplate(templateFunc: (args: T, utils: U) => string): Templatable<T, U> {
    this.template = (args: T) => templateFunc(args, this.utilities);
    return this.template;
  }

  /**
   * Sets the test data for this instance.
   *
   * @param data An object to be used as test data.
   */
  setTestData(data: T) {
    this.testData = data;
  }

  /**
   * Uses the test data to generate a string based on the current template.
   *
   * @returns A string generated by the current template and test data.
   * @throws Will throw an error if test data or template is undefined.
   */
  compileTestTemplate() {
    if (!this.testData) throw "Test Data undefined";
    if (!this.template) throw "Template undefined";
    return this.template(this.testData, this.utilities);
  }

  /**
   * Compiles the template with the provided data.
   *
   * @param `data` An object to be used as data for the template.
   * @returns A string generated by the current template and the provided data.
   * @throws Will throw an error if the template is undefined.
   */
  compileTemplate(data: T) {
    if (!this.template) throw "Error - template undefined";
    return this.template(data, this.utilities).trim();
  }
}

export interface KarozuOptions<U> {
  /**
   * Object containing utility functions defined by user.
   *
   * @example
   * utilities: { upperCase: (str: string) => str.toUpperCase() }
   */
  utilities: U;
  /**
   * String pointing to directory with templates.
   *
   * @example
   * templateDir: "src/templates"
   */
  templateDir: string;
  /**
   * String that will be compiled file name.
   *
   * @example
   * outputFileName: "compiled.md"
   */
  outputFileName: string;
}

/**
 * Karozu Class.
 *
 * @template U A record type that defines the shape of the utility functions.
 */
class Karozu<U extends { [key: string]: any }> {
  constructor(public options: KarozuOptions<U>) {}

  /**
   * Returns a function that creates `TemplateFile` instances with the currently set utilities.
   *
   * @returns A function that creates `TemplateFile` instances.
   * @template T A record type that defines the shape of the template data.
   */
  get createTemplateFile() {
    return <T extends { [key: string]: any }>() => {
      return new TemplateFile<T, U>({ utilities: this.options.utilities });
    };
  }
}

/**
 * `createKarozu` is a factory function that creates an instance of Karozu.
 * It takes a parameter { utilities } that is an object containing utility functions.
 * It returns an instance of the Karozu class.
 *
 * @param {KarozuOptions<U>} options - An options object used to initialize the Karozu.
 * @param {U} options.utilities - An object containing user-defined utility functions.
 *
 * @returns A new instance of the Karozu class with the supplied options.
 *
 * @example
 * const karozu = createKarozu({ utilities: { upperCase: (str: string) => str.toUpperCase() }});
 *
 * @template U The type infered from the utilities object which includes user-defined utility functions.
 */
export function createKarozu<U extends { [key: string]: any }>(
  options: KarozuOptions<U>,
) {
  return new Karozu<U>(options);
}
